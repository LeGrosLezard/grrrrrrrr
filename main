import cv2
import operator
import numpy as np
from PIL import Image
from matplotlib.pyplot import *
from collections import defaultdict
import math

from entrained import main

def create_blanck_image(img):
    """Black picture of img size"""

    blank_image = np.zeros((img.shape[0],img.shape[1],3), np.uint8)
    blank_image[0:img.shape[0], 0:img.shape[1]] = 0, 0, 0

    return blank_image


def clean_picture_little_noise(img):

    gray=cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    _, thresh = cv2.threshold(gray, 100, 255, 1)

    contours, _ = cv2.findContours(thresh, cv2.RETR_TREE,
                                   cv2.CHAIN_APPROX_SIMPLE)

    for i in contours:
        if cv2.contourArea(i) < 0.5:
            cv2.drawContours(thresh, [i], -1, (0,0,0), 1)

    cv2.imwrite("treatment.png", thresh)
    cv2.imshow("dzadza", thresh)
    cv2.waitKey(0)
    cv2.destroyAllWindows()


def fusion_contours():

    img = cv2.imread("treatment.png", 0);img = cv2.resize(img, (1400, 1000))

    _, thresh = cv2.threshold(img, 100, 255, 0)#100

    contours, _ = cv2.findContours(thresh, cv2.RETR_TREE,
                                    cv2.CHAIN_APPROX_SIMPLE)


    if len(contours) > 60:
        for i in contours:
            if cv2.contourArea(i) < 300:
                cv2.drawContours(img, [i], 0, (255,255,255), 3)
            
        cv2.imwrite("treatment.png", img)
        cv2.imshow("dzadzadaz1564984", img)
        cv2.waitKey(0)
        cv2.destroyAllWindows()




def find_contour_to_numbers(blank_image, numbers_position, image_prediction):


    img = cv2.imread("treatment.png", 0)
    _, thresh = cv2.threshold(img, 150, 255, 0)#40
    contours, _ = cv2.findContours(thresh, cv2.RETR_TREE,
                                   cv2.CHAIN_APPROX_SIMPLE)

    cv2.imshow("thresh123123", thresh)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

    for i in contours:
        if cv2.contourArea(i):

            x,y,w,h = cv2.boundingRect(i)
            cv2.fillPoly(blank_image, pts =[i], color=(255,255,255))

            crop = thresh[y-1:y+h+1, x-1:x+w+1]

            image_pil = Image.fromarray(crop).convert("LA")
            image_pil = image_pil.resize((8, 8), Image.ANTIALIAS)
            image_pil.save("treatment.png")

            prediction = main(len(contours))
            numbers_position.append([x, y])
            image_prediction.append(prediction)

            try:
                cv2.imshow("crop", crop)
                cv2.waitKey(0)
            except:
                pass




#-----------------------------------------------------out_capchat()
def initialise_dictionnary_pos_pred(numbers_position,
                                    image_prediction):
    dico = {}
    c = 0
    for i in numbers_position:
        dico[str(i)] = image_prediction[c]
        c+=1
    return dico

def all_position_by_x(numbers_position):

    liste = []
    list_work = []
    actual = 0
    for i in numbers_position:
        if i[1] != actual:
            liste.append(list_work)
            list_work = []

        list_work.append(i)
        actual = i[1]

    liste.append(list_work)

    return liste


def only_two_pos(liste):
    liste1 = []
    diff = 0
    for i in liste:

        if len(i) == 2:
            liste_w = []
            for j in i:
                liste_w.append(j)
            liste1.append(liste_w)

        elif len(i) >= 3:
            liste_w = []
            for j in i:
                if abs(diff) > 20:
                    i.remove(j)

                diff = j[0]
                liste_w.append(j)
            liste1.append(liste_w)

    return liste1



def put_position_y(liste1):
    liste2 = []

    if liste1[0][1] > liste1[1][1]:
        liste2.append(liste1[1])
        liste2.append(liste1[0])

    else:
        liste2 = liste1

    return liste2



def final_position_points(liste2, dico):
    pos1 = min(liste2[0])
    pos2 = max(liste2[0])
    pos3 = min(liste2[1])
    pos4 = max(liste2[1])


    liste_pos = [pos1, pos2, pos3, pos4]
    points = []
    for i in liste_pos:
        for key, value in dico.items():
            if str(i) == str(key):
                print(value)
                points.append(value)

    return points


def out_capchat(numbers_position, image_prediction):

    dico = initialise_dictionnary_pos_pred(numbers_position,
                                            image_prediction)


    position_x = all_position_by_x(numbers_position)
    final_position = only_two_pos(position_x)
    final_position = put_position_y(final_position)
    final_position = final_position_points(final_position, dico)

#-----------------------------------------------------out_capchat()


    
def open_img(image):

    numbers_position = []
    image_prediction = []


    img = cv2.imread(image)
    #Create blanck picture
    blank_image = create_blanck_image(img)
    #Save thresh who's cleanned < cnts noise
    clean_picture_little_noise(img)
    #We fusion contours who's separate by lines
    fusion_contours()
    #We want to find all numbers
    find_contour_to_numbers(blank_image,
                            numbers_position,
                            image_prediction)

    out_capchat(numbers_position, image_prediction)
    


def croping_y_picture(picture):
    img = cv2.imread(picture)
    
    y1 = int(img.shape[0] /6.5)
    crop = img[y1:img.shape[0]-100, 100:img.shape[1]]



if __name__ == "__main__":

    path = "picture/{}"
    image_package = ["a.png", "c.png", "d.png"]

    for i in image_package:
        croping_y_picture(path.format(i))
        img = open_img(path.format(i))
